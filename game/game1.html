<html>
<head>
<meta name='viewport' content='width=device-width'>
<style>
  html body {
    height: 100%;
  }
  body {
    margin: 0;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  table td {
    width: 30px;
    height: 34px;
    border: 1px solid #afafaf;
  }
  table td.inner {
    border: 1px #000000 solid;
  }
  table td.input {
    background: black !important;
  }
  table td:not([count="0"]) {
    background: #ccc;
  }
  .shake {
    animation: shake 0.1s;
    animation-iteration-count: 3;
  }
  @keyframes shake {
    0% { transform: translate(1px, 1px) rotate(0deg); }
    10% { transform: translate(-1px, -2px) rotate(-1deg); }
    20% { transform: translate(-3px, 0px) rotate(1deg); }
    30% { transform: translate(3px, 2px) rotate(0deg); }
    40% { transform: translate(1px, -1px) rotate(1deg); }
    50% { transform: translate(-1px, 2px) rotate(-1deg); }
    60% { transform: translate(-3px, 1px) rotate(0deg); }
    70% { transform: translate(3px, 1px) rotate(-1deg); }
    80% { transform: translate(-1px, -1px) rotate(1deg); }
    90% { transform: translate(1px, 2px) rotate(0deg); }
    100% { transform: translate(1px, -2px) rotate(-1deg); }
  }
</style>
<script>
  function getPosition(cell) {
    var pos = cell.getAttribute('id').split('_');
    var x = parseInt(pos[0]);
    var y = parseInt(pos[1]);
    return { x, y };
  }
  function isPosCollisional(pos1, pos2) {
    return pos1.x == pos2.x || pos1.y == pos2.y ||
        Math.abs(pos1.x - pos2.x) == Math.abs(pos1.y - pos2.y);
  }
  function forAllCells(table, match_op, matched_cb) {
    for (let rows of table.rows) {
      for (let cell of rows.cells) {
        if (match_op(cell)) {
          matched_cb(cell);
        }
      }
    }
  }
  function checkCollision(table, target_cell, callback) {
    const target_pos = getPosition(target_cell);
    forAllCells(table, (cell)=>{
      const pos = getPosition(cell);
      return isPosCollisional(target_pos, pos);
    }, callback);
  }
  function shakeCollisionalInputCells(table, clicked_cell) {
    const clicked_pos = getPosition(clicked_cell);
    forAllCells(table, (cell)=>{
      const pos = getPosition(cell);
      return cell.classList.contains('input') &&
             isPosCollisional(clicked_pos, pos);
    }, (cell)=>{
      cell.classList.add('shake');
      cell.addEventListener("animationend", () => {
        cell.classList.remove('shake');
      });
    });
  }
  function init() {
    const table_size = 8;
    var table = document.createElement('table');
    for (var i = 0; i < table_size; i++) {
      let line = table.insertRow();
      for (var j = 0; j < table_size; j++) {
        let cell = line.insertCell();
        cell.setAttribute('id', i + '_' + j);
        cell.setAttribute('count', 0);
        if (i != 0 && i != table_size - 1 && j != 0 && j != table_size - 1) {
          cell.classList.add('inner');
        }
        cell.addEventListener('click', () => {
          if (cell.classList.contains('input')) {
            cell.classList.remove('input');
            checkCollision(table, cell, (matched)=>{
              var count = parseInt(matched.getAttribute('count'));
              matched.setAttribute('count', count-1);
            });
          } else {
            var clickable = parseInt(cell.getAttribute('count')) == 0;
            if (!clickable) {
              shakeCollisionalInputCells(table, cell);
              return;
            }
            cell.classList.add('input');
            checkCollision(table, cell, (matched)=>{
              var count = parseInt(matched.getAttribute('count'));
              matched.setAttribute('count', count+1);
            });
          }
        });
      }
    }
    document.body.append(table);
  }
  window.addEventListener('load', init);
</script>
</head>
<body></body>
</html>
